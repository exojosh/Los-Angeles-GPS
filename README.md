# Los-Angeles-GPS
Functional and optimized GPS for arbitrary set of OpenMaps coordinates

=================
| 	Josh Limon	|
|	Project 4	    |
|	readme.txt	  |
=================

Quick Note: provided.h is a file provided by Professor Smallberg who assigned this project. Credit goes to Professors Smallberg and Nanchenburg for formatting and distributing mapdata.txt (and deliveries.txt).

Quick Note 2.0: GPS works for arbitrary set of OpenMaps data points (formatted akin to mapdata.txt but mapdata.txt only uses Los Angeles streets.
	Note 2.5: Load time is proportional to amount of coordinates in mapdata.txt


--------------------
|GPS Functionality |
--------------------
This is a functional GPS that takes a set of OpenMaps coordinates formatted akin to mapdata.txt, and finds an optimal route to all coordinates given in "deliveries.txt".
ExpandableHashMap structure and class made by me, along with streetmap.cpp (reads and formats data),  PointToPointRouter.cpp (creates routes between points optimized by an A* algorithm), DeliveryOptimizer.cpp (optimizes distance travelled for delivery), and DeliveryPlanner.cpp (implements other classes)


--------------------
|Note on Usage     |
--------------------
To use, first extract GPS.zip and use Windows command line to navigate to extracted directory (e.g. D:\Downloads\CS 32 Project 4) then run
P4.exe with arguments "mapdata.txt deliveries.txt"

I.e. run with cmd command 
C:\EXTRACTEDDIRECTORY> P4.exe mapdata.txt deliveries.txt

-------------
|StreetMap  |
-------------
load():

If the mapdata.txt has N lines then load() runs in O(N) time as it does an O(1)
operation on each line of text.

getSegmentsThatStartWith():
This method's computation time is determined by the ExpandableHashMap's find()
function. This function therefore runs in O(1) time on average and O(N) worst
case where N is the number of streetmaps in mapdata.txt (tho the latter case
almost never occurs since that requires every segment to collide to the same
node and a good load factor helps prevent this).



---------------------
|PointToPointRouter |
---------------------

generatePointToPointRoute():
Uses an A* algorithm with simple euclidian distance from current GeoCoord to goal
as the heuristic function. Therefore greedy and non-optimal but ran out of time to
test other constraints.

In terms of the used data structures, I use a list as the container of StreetSegments
on the route generated by the funciton and I use ExpandableHashMap to map geocoords
to their gscores and fscores in two maps for each respective value. Finally,
for storing values of prev coords, I use an ExpandableHashMap as well for quick access
on reconstruction of route.


--------------------
|DeliveryOptimizer |
--------------------

optimizeDeliveryOrder():
This method employs the multi-fragment algorithm (connect two shortest segments then
connect next shortest segments that don't complete the loop until you connect a
final segment that makes a hamiltonian cycle).

If there are N delivery requests, then the function runs in O(n+1) time (has
